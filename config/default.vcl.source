vcl 4.0;
import std;
import vsthrottle;

backend default {
  .host = "$(eval "echo \$BACKEND_PORT_${BACKEND_ENV_PORT}_TCP_ADDR")";
  .port = "${BACKEND_ENV_PORT}";
}

# Handling of requests that are received from clients.
# First decide whether or not to lookup data in the cache.
sub vcl_recv {
  # Pipe requests that are non-RFC2616 or CONNECT which is weird.
  if (req.method != "GET" &&
      req.method != "HEAD" &&
      req.method != "PUT" &&
      req.method != "POST" &&
      req.method != "PATCH" &&
      req.method != "TRACE" &&
      req.method != "OPTIONS" &&
      req.method != "DELETE") {
    return(pipe);
  }

  if (req.http.Authorization || req.http.Authenticate) {
    return(pass);
  }

  # Pass requests that are not GET or HEAD
  if (req.method != "GET" && req.method != "HEAD") {
    return(pass);
  }

  if (vsthrottle.is_denied("ip:" + client.ip, ${THROTTLE_LIMIT_NUMBER}, ${THROTTLE_LIMIT_TIME})) {
    return (synth(429, "Too Many Requests"));
  }

  if (req.http.x-forwarded-for) {
    set req.http.X-Forwarded-For = req.http.X-Forwarded-For + ", " + client.ip;
  } else {
    set req.http.X-Forwarded-For = client.ip;
  }

  # Handle compression correctly. Varnish treats headers literally, not
  # semantically. So it is very well possible that there are cache misses
  # because the headers sent by different browsers aren't the same.
  # @see: http://varnish.projects.linpro.no/wiki/FAQ/Compression
  if (req.http.Accept-Encoding) {
    if (req.http.Accept-Encoding ~ "gzip") {
     # if the browser supports it, we'll use gzip
     set req.http.Accept-Encoding = "gzip";
    } elsif (req.http.Accept-Encoding ~ "deflate") {
     # next, try deflate if it is supported
     set req.http.Accept-Encoding = "deflate";
    } else {
     # unknown algorithm. Probably junk, remove it
     unset req.http.Accept-Encoding;
    }
  }

  # Clear cookie and authorization headers, set grace time, lookup in the cache
  unset req.http.Cookie;
  unset req.http.Authorization;
  return(hash);
}

# Called when entering pipe mode
sub vcl_pipe {
  set bereq.http.Connection = "close";

  if (req.http.X-Forwarded-For) {
    set bereq.http.X-Forwarded-For = req.http.X-Forwarded-For;
  } else {
    set bereq.http.X-Forwarded-For = regsub(client.ip, ":.*", "");
  }
  return (pipe);
}

sub vcl_pass {
  #return (pass);
}

# Called when the requested object has been retrieved from the
# backend, or the request to the backend has failed
sub vcl_backend_response {
  # Set the grace time
  set beresp.grace = ${GRACE_MAX};

  # Do not cache the object if the status is not in the 200s
  if (beresp.status >= 300) {
    # Remove the Set-Cookie header
    unset beresp.http.Set-Cookie;
    set beresp.uncacheable = true;
    return(deliver);
  }

  # Do not cache the object if the backend application does not want us to.
  if (beresp.http.Cache-Control ~ "(no-cache|no-store|private|must-revalidate)") {
    set beresp.uncacheable = true;
    return(deliver);
  }

  if (beresp.ttl <= 0s ||
    beresp.http.Set-Cookie ||
    beresp.http.Vary == "*") {
    /*
    * Mark as "Hit-For-Pass"
    */
    set beresp.ttl = ${GRACE_TTL};
    set beresp.uncacheable = true;
    return (deliver);
  }

  # Everything below here should be cached

  # Remove the Set-Cookie header
  unset beresp.http.Set-Cookie;

  # Deliver the object
  return (deliver);
}

# Called before the response is sent back to the client
sub vcl_deliver {

  # Exclui os assets do revalidate
  if (! (req.url ~ "^/(assets|images|uploads)")) {
    # Force browsers and intermediary caches to always check back with us
    set resp.http.Cache-Control = "private, max-age=0, must-revalidate";
    set resp.http.Pragma = "no-cache";
  }

  # Add a header to indicate a cache HIT/MISS
  if (obj.hits > 0) {
    set resp.http.X-Cache = "HIT";
  } else {
    set resp.http.X-Cache = "MISS";
  }

  return (deliver);
}

sub vcl_backend_error {
  set beresp.http.Content-Type = "application/json; charset=utf-8";
  set beresp.http.Retry-After = "5";
  synthetic ({"{
  "status":""} + beresp.http.status + {"",
  "response":""} + beresp.http.response + {"",
  "xid":""} + bereq.xid + {"",
  "message":"Varnish cache server error"
  }"});
  return (deliver);
  }

  sub vcl_init {
  return (ok);
}
